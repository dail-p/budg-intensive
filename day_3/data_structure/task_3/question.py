"""
Посмотрите сколько памяти занимают следующие объекты.
Сколько будет занимать памяти список с двумя элементами после добавления в него
еще одно элемента с помощью append? Почему?
"""

first_tuple = (1, 2)
second_tuple = (1, 2, 3)
first_list = [1, 2]
second_list = [1, 2, 3]


print(first_tuple.__sizeof__())
print(second_tuple.__sizeof__())
print(first_list.__sizeof__())
print(second_list.__sizeof__())

first_list.append(3)
print(first_list.__sizeof__())
first_list.append({'a': 2, 's': 3})
print(first_list.__sizeof__())
print('\n')

"""
Изначался список с двумя элементами занимает 40 + 8*2 байта. Метод 
аppend при выполнении вызывает метод, который выделяет память до 8 мест (список при этом из 3 элементов остается), 
поэтому после добавления элемента он занимеет 40 + 8*8 байта. Память под новые 8 мест не будет выделена, пока предыдущие
не заполнятся. При этом список содержит 8-байтовые указатели(в 64-битных версиях Python) на 
фактический объект int(или на словарь, это не важно).
"""

test = [0]
for item in range(500):
    print(str(test.__sizeof__()) + ' || ' + str(len(test)) + ' || Выделено мест ' + str((test.__sizeof__() - 40)/8))
    test.append(item)


"""
Если начинать с пустого списка, 
то выделение памяти задается следующей последовательностью: 0, 4, 8, 16, 24, 32, 40, 52... 
То есть выделяемая память добовляется в соответсвии с последовательностью: +4, +8, +12, +16, +20...
При этом мне не понятно, по какому принципу определяется сколько раз будет добавленно по 8 мест, а сколько по 20.

Если начинать не с пустого списка, то все то же самое, но вначале выделяется память сразу под 8 мест
"""
